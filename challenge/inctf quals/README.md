## Challenge Name : Duplicates

DESCRIPTION:
Is it possible to duplicate?

FLAG FORMAT:
inctf{...}

#### Challenge file:

```
from Crypto.Util.number import getPrime
from secret import flag
pt=int(flag.hex(),16)

def gen():
    p,q=getPrime(512),getPrime(512)
    e,n=65537,p*q
    ct=pow(pt,e,n)
    d=pow(e,-1,(p-1)*(q-1))
    return ct,d,n,[p,q]

if __name__ == '__main__':
    ct,d1,n,pq=gen()
    print(pq)
    d2=int(input("> "))
    if d2!=d1:
        if pow(ct,d2,n)==pt:
            print(f"Good Job!!\n{flag.decode()}")
        else:
            print("bruh")
    else:
        print("Are you for real??")
```

- The challange runs on the remote instance where we have to give the value of `d`  to decrypt the flag.
- We were given with values of `p` and `q` when running the instance.

```
pq = [9271027477113701235755350545719977174599676462901577644714811380208294215204090221612185375557990680124488952535641704656501628556848766875472425673189497, 9138046549037796433974516840615141901475690892121490151554506619221318177641251570519278540381108700024825885518437955535114986879514659998608890291099949]
```
#### RSA simple caculations

```
p = pq[0]
q = pq[1]
phi = (p-1) * (q-1)
e=65537 #given
    
d = inverse(e,phi)

With d we can decrypt the plaintext.
```
- But the twist here is gen() already generated d with the same formula  `d1=pow(e,-1,(p-1)*(q-1))`
- The user given input is taken as `d2` and if `d1 == d2`,we will be exit from the instance saying "Are you for real??"
- If we give some other values for `d` ,we will get exit from the instance saying "bruh".
- Our soultion lies on finding `d2` which does not match with d1 but still able to decrypt the plaintext when passing in the equation pow(ct,d2,n).
- Upon googling able to find the below converstation on multiple rsa private keys(d).

   https://crypto.stackexchange.com/questions/39486/is-it-possible-to-have-multiple-rsa-private-keys

   <img src="images/duplicates2.png" width="350" height="100" />

- Upon understanding we get to know the formula `e^-1 mod(lcm(p-1)*(q-1))`.
- This is to find the minimal decrypting exponent and we can call this as `d2`.
- Hence we satisfied `d2 != d1` and we can now decrpty the plaintext.

```
d2 = inverse(e,gmpy2.lcm(p-1,q-1))
```
- Sending d2 to the instance we get the flag 
 "Good Job!!
  inctf{Seems_l1k3_LCM_1s_n0t_Us3less} "
  
  #### Flag:
   inctf{Seems_l1k3_LCM_1s_n0t_Us3less}
   
## Challenge Name : common-extender

DESCRIPTION
Break the box to get the flag

FLAG FORMAT:
inctf{...} 

Challenge file:
```
from Crypto.Util.number import *
from secret import *
p=getPrime(1024)
q=getPrime(1024)
n=p*q
e=65537
e1=5**e 
e2=7**e
m=bytes_to_long(flag)
c1=pow(m,e1,n)
c2=pow(m,e2,n)
f=open('common.txt','wb')
f.write('c1 ='+str(c1)+'\n')
f.write('c2 ='+str(c2)+'\n')
f.write('n ='+str(n)+'\n')

output:

c1=4723005985613543187020628938921653359117769920118354915283034471439951923751100042324993738873335720499784832162124494724397874077445927539518170906182303071332375503334377466642151794243893906686488318314054581277279339354540824560289281377642476956195085157598596806724741328453851091266048989755240316042334268749726482498290550751421726074890664103854548877867102449424289393328824577607388404132540469861201309536143850843812921167352182401864201559799676471710328882434530114454019475040002543619441854896467180130953718013265450930254533163800232807408091288735463359738179843762952219190997088933076463800937

c2=10661271147018941693868519425015420669304227031149199140791386970019096952927137416689438586221525636852501069518071596639264468645491045897884647407076730835292758137798902431649278166782296895082822129633563506818700870154189144836361676276555629751239323641469875120324974236823100525239750663787201418512480903774505519091161838612044303655990682336151817250392594652014609590192456834512948777394553397026821855860329964005565294653826280257960557756783979076491069339465500539440222774123086569145442457693185866956898675083518702635078528584279392938595697812726333735052589820594259874406841682091739678524166

n=11155969736975030321603841672525295227570716210595590699453614058237981426469332282238600717214610633264384213690995769680221614766192515074958634372975469729171515398846583529856706120844739718236545956568085134178568177454529312263751145892952154745569078370817794422735815658766976052106764697692513578131712594084459526863090016695367406601060344189805521965430081209261308855001306956480675881885019593474575445953467735810323250937035075578541754977140680224088631592773035911479161549529768832799346709755779715883372921257849085412674123966236800311386984918023151443206911776079574398957068052132081309547789
```
- Above were the given chall.py and its output.
- Based on initial observation we can see the values `c1,c2,e1,e2,n` > Here the flag `m` is being encrypted into two ciphertexts `c1 and c2` with two different exponents `e1 and e2` by using same modulus.
- Hence this method is vulnerable to common modulus attack ==> https://infosecwriteups.com/rsa-attacks-common-modulus-7bdb34f331a5
- We are going to do the math explained in the above writeup.
- if gcd(e1,e2) = 1 then the integers s1 and s2 is `s1e1+s2e2 =1`

```
>>> import gmpy2
>>> e = 65537
>>> e1 = 5**e
>>> 
>>> e2 = 7**e
>>> 
>>> gmpy2.gcd(e1,e2)
mpz(1)
>>> 
```
- We can use extended euclidean to find `s1` and `s2` and by doing so we had `s1` as negative integer and `s2` as positive integer.
- Then need to inverse `c1` since `s1` is negative.
```
m1 = pow(c1inversed,s1,N)

# 1/c1 ** s1 % N
m2 = pow(c2,s2,N)
# c2 ** s1 % N
flag = (m1 *m2)%N
```
- By doing the above equation we can obtain the flag.

Full script

```
import gmpy2, binascii
from Crypto.Util.number import *

e=65537
e1 = 5**e
e2 = 7**e
c1=4723005985613543187020628938921653359117769920118354915283034471439951923751100042324993738873335720499784832162124494724397874077445927539518170906182303071332375503334377466642151794243893906686488318314054581277279339354540824560289281377642476956195085157598596806724741328453851091266048989755240316042334268749726482498290550751421726074890664103854548877867102449424289393328824577607388404132540469861201309536143850843812921167352182401864201559799676471710328882434530114454019475040002543619441854896467180130953718013265450930254533163800232807408091288735463359738179843762952219190997088933076463800937
c2=10661271147018941693868519425015420669304227031149199140791386970019096952927137416689438586221525636852501069518071596639264468645491045897884647407076730835292758137798902431649278166782296895082822129633563506818700870154189144836361676276555629751239323641469875120324974236823100525239750663787201418512480903774505519091161838612044303655990682336151817250392594652014609590192456834512948777394553397026821855860329964005565294653826280257960557756783979076491069339465500539440222774123086569145442457693185866956898675083518702635078528584279392938595697812726333735052589820594259874406841682091739678524166
N=11155969736975030321603841672525295227570716210595590699453614058237981426469332282238600717214610633264384213690995769680221614766192515074958634372975469729171515398846583529856706120844739718236545956568085134178568177454529312263751145892952154745569078370817794422735815658766976052106764697692513578131712594084459526863090016695367406601060344189805521965430081209261308855001306956480675881885019593474575445953467735810323250937035075578541754977140680224088631592773035911479161549529768832799346709755779715883372921257849085412674123966236800311386984918023151443206911776079574398957068052132081309547789


solvable = gmpy2.gcd(e1,e2)

print(solvable) #If gcd(e1,e2) = 1 , then we can recover plaintext

# 1 

#Bezouts theorem states that xa+yb = gcd(a,b)

# e1a+e2b = gcd(e1,e2)

# e1a+e2b =1


g, s1, s2 = gmpy2.gcdext(e1, e2)

#Doing extended euclidean to find the values s and t
#using gmpy since the value of e is too large that we would get non divisible float error !
assert e1 * s1 + e2 * s2 == 1
#Only true while e1s1+e2s2 = 1

#s1 is an negative integer
#s2 is an positive integer

c1inversed = gmpy2.invert(c1, N)

#inversing c1 since s1 is negative
m1 = pow(c1inversed,s1,N)

# 1/c1 ** s1 % N
m2 = pow(c2,s2,N)
# c2 ** s1 % N
final = (m1 *m2)%N

print(long_to_bytes(final))


#Flag : inctf{common_modulus_uses_extended_gcd}
```
### Flag:
inctf{common_modulus_uses_extended_gcd}
